from collections import OrderedDict
from uuid import uuid4

from flask import (
    jsonify,
    Blueprint,
    request
)
from flask.views import MethodView
from flask_jwt_extended import (
    get_jwt_identity,
    create_access_token,
    create_refresh_token,
    jwt_required,
    current_user
)

from ..serializer import (
    UserRegisterSerializer, 
    UserLoginSerializer
)
from ..utils.user import UserType
from ..database import db_session
from ..models.user import User
from ..models.address import Address
from ..models.validation import Validation
from ..utils.message import message_collector
from ..utils.validation import password_validation


bp = Blueprint("auth", __name__, url_prefix="/api/auth")


class RegisterView(MethodView):
    
    def __init__(self, model):
        self.model: User = model
        self.mc = message_collector()
        
    def check_user_exists(self, username: str) -> bool:
        query = db_session.query(User).where(self.model.username==username).all()
        if len(query) > 0:
            return True
        return False
    
    def get_user_type(self, value):
        """
        Return appropriate User roles
        """
        if UserType.Employee.value == value:
            return UserType.Employee
        if UserType.TeamLead.value == value:
            return UserType.TeamLead
        if UserType.Manager.value == value:
            return UserType.Manager
        return 0
    
    def post(self):
        try:
            serializer = UserRegisterSerializer(**request.json)
        except (AttributeError, TypeError) as e:
            # generated by serialier
            return jsonify(message="Invalid fields username, role"), 400
        
        # check user existence
        if self.check_user_exists(serializer.username):
            return jsonify(message="User name taken"), 302
        
        # check password length
        if len(serializer.password) < 8:
            return jsonify(message="Password must be atleast digit"), 400
        
        # check user role
        user_role = self.get_user_type(serializer.role)
        if not user_role:
            return jsonify(message="Invalid user role."), 400
        
        # add user
        user = self.model(
            username=serializer.username, 
            password=User.make_passsword(serializer.password),
        )
        user.role = user_role
        user.account_activation_id = uuid4()
        db_session.add(user)
        db_session.commit()
        
        self.mc("User created successfully")
        self.mc(f"Click on the following link to activate the account: /api/auth/register/{user.id}/{user.account_activation_id}")
        return jsonify(
            message=self.mc(),
        ), 201

class AccountActivateView(MethodView):
    def get(self, user_id, act_id):
        user = db_session.query(User).filter_by(id=user_id).one_or_none()
        user.account_activation = True
        db_session.add(user)
        db_session.commit()
        return jsonify(message="User account successfully activated")

class LoginView(MethodView):
    def __init__(self, model):
        self.model = model
        
    def post(self):
        
        try:
            serializer = UserLoginSerializer(**request.json)
        except (AttributeError, TypeError) as e:
            # generated by serialier
            return jsonify(message="Required username and password"), 400
        
        # get user active and account_activation check
        user = db_session.query(User).filter(User.username==serializer.username).one_or_none()
        if not user or not user.active:
            return jsonify(message="User not found"), 404
        
        # account activation check
        if not user.account_activation:
            return jsonify(
                message=f"Click on the following link to activate the account: /api/auth/register/{user.id}/{user.account_activation_id}"
            )
        
        # check password
        if not user.check_password(serializer.password):
            return jsonify(message="Invalid username and password"), 400
        
        data = OrderedDict()
        data["message"] = "User successfully logged in"
        data["access_token"] = create_access_token(identity=user, fresh=True)
        data["refresh_token"] = create_refresh_token(identity=user)
        
        return jsonify(data), 200


def register_api(app: Blueprint, model: User, name: str, view_class=None):
    app.add_url_rule(
        f'/{name}', 
        view_func=view_class.as_view(f"user-{name}", model)
    )
        

register_api(bp, User, 'register', RegisterView)
register_api(bp, User, 'login', LoginView)
bp.add_url_rule("/register/<int:user_id>/<act_id>", view_func=AccountActivateView.as_view("user-activation"))


@bp.post("/refresh")
@jwt_required(refresh=True)
def refresh_token():
    """
    Refresh user token
    """
    identity = get_jwt_identity()
    
    user = db_session.query(User).filter_by(id=int(identity)).one_or_none()
    if not user:
        return jsonify(message="Invalid refresh token"), 401
    
    access_token = create_access_token(identity=user, fresh=False)
    
    return jsonify(access_token=access_token)


@bp.post("/password-reset")
@jwt_required(fresh=True)
def reset_logged_user_password():
    """
    Reset the password of logged in user.
    """
    
    try:
        password = request.json.get("password")
    except (AttributeError, TypeError) as e:
        return jsonify(message=str(e)), 400
    
    if len(password) < 8:
        return jsonify(message="Password must be atleast 8 digits"), 400
    
    current_user.password = User.make_passsword(password)
    db_session.add(current_user)
    db_session.commit()
    
    return jsonify(message="Password changed successfully")
    
    
@bp.post("/password-reset-unknown")
def reset_unknown_user_password():
    """
    Reset password of unknown user. Email required.
    """
    try:
        email = request.json.get("email")
    except (AttributeError, TypeError) as e:
        return jsonify(message=str(e)), 400
    
    try:
        user = db_session.query(User).filter_by(email=email).one_or_none()
        print(f"\n\n{user}\n\n")
    except Exception as e:
        # multiple email association
        return jsonify(message=str(e)), 400
    
    # user with email found
    if user:
        validation = Validation(
            id = uuid4(),
            user_id=user.id
        )
        db_session.add(validation)
        db_session.commit()
        
        link = f"Click on the following link to update password: /api/auth/password-reset-unknown/{validation.id}"

        return jsonify(
            message=link
        ), 202
        
    # email not found
    return jsonify(message="User not found"), 400


@bp.post("/password-reset-unknown/<val_id>")
def reset_password_using_validation_id(val_id: str):
    
    try:
        validation: Validation = db_session.query(Validation).get({"id":val_id})
        if not validation or not validation.active:
            raise ValueError("Invalid validation ID")
        
        password = request.json.get("password")
        pass_valid = password_validation(password)
        if not pass_valid[0]:
            return jsonify(message=pass_valid[1]), 400
        
        user: User = db_session.query(User).get({"id":validation.get_user_id})
        user.password = User.make_passsword(password)
        
        db_session.add(user)
        db_session.commit()
        
        validation.active = False
        db_session.add(validation)
        db_session.commit()
        
    except Exception as e:
        return jsonify(message=[
            "Invalid link",
            str(e)
        ]), 400
    
    return jsonify(message="Password reset successfully"), 202

